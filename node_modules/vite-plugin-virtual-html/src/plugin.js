"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// noinspection UnnecessaryLocalVariableJS
const vite_1 = require("vite");
const types_1 = require("./types");
const devUtils_1 = require("./devUtils");
const buildUtils_1 = require("./buildUtils");
const path_1 = __importDefault(require("path"));
const fs_1 = __importStar(require("fs"));
const utils_1 = require("./utils");
exports.default = (virtualHtmlOptions) => {
    const { pages: pagesObj, indexPage = 'index', render: globalRender = (template) => template, data: globalData = {}, extraGlobPattern = [], injectCode = {} } = virtualHtmlOptions;
    let pages;
    if (pagesObj === true || pagesObj === undefined) {
        pages = (0, utils_1.findAllHtmlInProject)(extraGlobPattern);
    }
    else {
        pages = pagesObj;
    }
    let _config;
    let distDir;
    const needRemove = [];
    return {
        name: 'vite-plugin-virtual-html',
        configureServer(server) {
            // other html handled after vite's inner middlewares.
            return () => {
                server.middlewares.use('/', async (req, res, next) => {
                    var _a, _b;
                    let url = decodeURI((0, devUtils_1.generateUrl)(req.url));
                    // if request is not html , directly return next()
                    if (!url.endsWith('.html') && url !== '/') {
                        return next();
                    }
                    // if request / means it request indexPage htmlCode
                    // read indexPage config ,and response indexPage htmlCode
                    let htmlCode;
                    if (url === '/' || url.indexOf('index.html') >= 0) {
                        url = `/${indexPage}.html`;
                        // @ts-ignore
                        htmlCode = (_a = await this.load((0, vite_1.normalizePath)(url))) !== null && _a !== void 0 ? _a : '';
                    }
                    else {
                        // @ts-ignore
                        htmlCode = (_b = await this.load(url)) !== null && _b !== void 0 ? _b : '';
                    }
                    // @ts-ignore
                    res.write(await server.transformIndexHtml(url, await this.transform(htmlCode, url)));
                    next();
                });
            };
        },
        async transform(code, id) {
            if (id.indexOf('.html') >= 0) {
                const ids = id.split('/');
                const key = ids[ids.length - 1];
                if (key in injectCode) {
                    return (0, utils_1.generateInjectCode)(injectCode[key], code);
                }
                if (types_1.DEFAULT_INJECTCODE_ALL in injectCode) {
                    return (0, utils_1.generateInjectCode)(injectCode[types_1.DEFAULT_INJECTCODE_ALL], code);
                }
            }
            return code;
        },
        async config(config, { command }) {
            var _a, _b, _c, _d, _e;
            _config = config;
            if (command === 'build') {
                const allPage = Object.entries(pages);
                // copy all html which is not under project root
                for (const [key, value] of allPage) {
                    const pageOption = await (0, devUtils_1.generatePageOptions)(value, globalData, globalRender);
                    const vHtml = (0, vite_1.normalizePath)(path_1.default.resolve(types_1.cwd, `./${config.root ? (0, buildUtils_1.addTrailingSlash)(config.root) : ''}${key}.html`));
                    if (!fs_1.default.existsSync(vHtml)) {
                        needRemove.push(vHtml);
                        await checkVirtualPath(vHtml, needRemove);
                        await fs_1.promises.copyFile(path_1.default.resolve(types_1.cwd, `.${pageOption.template}`), vHtml);
                    }
                }
                console.warn('NOTICE: This plugin cannot use in library mode!');
                // get custom distDir config,if it is undefined use default config 'dist'
                distDir = (_b = (_a = config.build) === null || _a === void 0 ? void 0 : _a.outDir) !== null && _b !== void 0 ? _b : 'dist';
                // inject build.rollupOptions.input from pages directly.
                config.build = {
                    ...config.build,
                    rollupOptions: {
                        ...(_c = config.build) === null || _c === void 0 ? void 0 : _c.rollupOptions,
                        input: {
                            ...(_e = (_d = config.build) === null || _d === void 0 ? void 0 : _d.rollupOptions) === null || _e === void 0 ? void 0 : _e.input,
                            ...(0, buildUtils_1.extractHtmlPath)(pages),
                        },
                    },
                };
            }
        },
        async load(id) {
            if (id.endsWith('html')) {
                const newId = (0, buildUtils_1.getHtmlName)(id, _config === null || _config === void 0 ? void 0 : _config.root);
                if (pages[newId] !== undefined) {
                    const page = await (0, devUtils_1.generatePageOptions)(pages[newId], globalData, globalRender);
                    // generate html template
                    return await (0, devUtils_1.readHtml)(page);
                }
            }
            return null;
        },
        async closeBundle() {
            // remove files should not be under project root
            for (let vHtml of needRemove) {
                if (fs_1.default.existsSync(vHtml)) {
                    await fs_1.promises.rm(vHtml, {
                        recursive: true,
                    }).catch(() => {
                        // ignore this warning
                    });
                }
            }
        },
    };
};
/**
 * check html file's parent directory
 * @param html
 * @param needRemove
 */
async function checkVirtualPath(html, needRemove) {
    const pathArr = html.split('/');
    const fileName = pathArr[pathArr.length - 1];
    const middlePath = html.replace(fileName, '').replace(types_1.cwd, '');
    const firstPath = middlePath.split('/')[1];
    if (!fs_1.default.existsSync(middlePath)) {
        needRemove.push((0, vite_1.normalizePath)(path_1.default.resolve(types_1.cwd, `./${firstPath}`)));
        await fs_1.promises.mkdir(path_1.default.resolve(types_1.cwd, `./${middlePath}`), {
            recursive: true
        });
    }
}
//# sourceMappingURL=plugin.js.map